ORM : Object Relationship Mapping, a programming technique used in software development to convert data between incompatible type system in object-oriented programming languages. This technique creates a "virtual object database" that can be used from within the programming language

Mongoose is kind of ORM only, more specifically it is ODM => Object Document Mapping

Easier defination : ORMs let you easily interact with your database withot worrying too much about the underlying syntax (SQL language for example)
Eg - SQL injections can be prevented 
![alt text](image.png)

WHY ORMS ? -----------------------------------------------
1. Simpler syntax ![alt text](image-1.png)
2. Abstraction that let'so you flip databases you are using.   ![alt text](image-2.png)
   -> Migration of data from one database to another is hard, but queries in backend won't change
3. Type Safety/ Auto Completion
   -> ![alt text](image-3.png)
  
4. Auto Migrations 
In case of simple postgres app, it is hard to track what all queries ran and led to this state of the database.
(Say, you have created initial setup of CREATE TABLE in atabase, but after some time you have to add some extra column in already existing table. The you are migrating from previous structural state of db to new one. So you need to have track of these) (So, say more than one developer is working in dev environment, then the migrations that you ran you have to keep them saved somewhere so, another developer can also run those, in order to work on same type of database)
(All migrations should be in single folder and this schema needs to be shared with everyone in development team)
(Now, while using PRISMA these all migrations happen themselves and get saved too)
(So, If you have to work on CMS, and in order to setup your environment, you will have to run all migrations queries on your postgreSQL database. In Single Command, you can run all of these)

WHAT IS PRISMA ----------------------------------------------------

Prisma is just One of the ORMs, Drizzle is another one
Prisma : NodeJS and TS ORM, It has intuitive data model, automated migrations, type-safe and auto-comoletion

1. Data Model : In single file, you can define your schema.What is looks like, what tables you have, what field each table has, how are rows related to each other.
   -> CMS schema : ![alt](image-4.png), you can now make changes in here in schema file and then run one single command and your migrations will be created and database will be updated accordingly

2. Automated migrations : PRISMA generates and runs database migrations based on changes to prisma shcema
3. Type Safety 
4. Auto Completion


INSTALLLING PRISMA and Setting up---------------------------------------
 >> npm install prisma
 >> npx prisma init

 -> now put postgreSQL link in env file generated by prisma
 -> then add model for tables in schema
 >> npx prisma migrate dev
 >> npx prisma migrate dev --dry-run

 -> doing joins in prisma is tricky


If you have to delte some column from the table inside Schema, then it is easy, easily remove in schema but if you want to add new Column to a a table that already have some data into it, the either make new column as optional or add default value to it :-

model Todos {
  id            Int     @default(autoincrement())   @id
  title         String
  decription    String
  done          Boolean
  user_id       Int
  time          DateTime?
  OR 
  time          DateTime @Default(now())
}


Generating Prisma Client ------------------------------------------------------------
![Autogenerated Client](image-5.png)
Client :  lets you interact from database, it has logic to write database queries

one of generator client : "prisma-client-js"

Client represents all the functions that convert :

User.create({email:"aaus@gmai.com})
into
INSERT INTO users VALUES...


RELATIONSHIPS IN PRISMA ----------------------------------------------------------------
relationships to relate tables to each other, donot add all data into single table, normalise your database, break into tables and create relationships between those tables

![definning relationships in prisma is little wiered you have to define it in two places](image-6.png)


EXPRESSIFYING ALL ------------------------------------------------------------------------
Now, create a basic todo backend, with PRISMA as ORM, PostgreSQL as database



>> npx prisma generate

Todo :-
1. Dynamo DB and cloudfare service : scales well
2. Drizzle, explore Drizzle vs Prisma
3. try to see what raw query has gone to the database
4. Few more things to learn in PRISMA :
   -> how to add paginations
   -> how to perfrom JOINS
   -> how to do diff relationships : one-to-one, one-to-many, many-to-one OR many-to-many


5. Bulding CMS : integrating WebRTC : using lifekit for webRTC [it wil be easy], If you are building webRTC SFUs inhouse [really hard]. If you use something openSource then making is easy but deploying it is bit hard, use PION or MEDIASUP or LIFEKIT one of these       
6. Seeding data in db : 
   -> Seeding : It means feeding some dummy data to the database, so whenever a new developer comes when they clone the project they do have some dummy data to work with, and test their code
   So, in prisma in order to add seeding data , you just add a seed.ts file and add code as shown in learning folder

   NOW THERE ARE BUNCH OF STEPS YOU NEED TO FOLLOW
   -> FOLLOW ALONG :-
   >> npx prisma db seed
   // if you get error then do following :-
   add 
   ```
   "prisma" : {
      "seed" : "ts-node prisma/seed.ts"
   }
   ```
   in package.json file

   THEN after this add following dependencies 
   >> npm i -D ts-node typescript @types/node

7. bcrypt vs argon2 for hashing passwords :  use argon2   
8. nodeJs and Voip [Voip and WebRTC both have this initial challenge, once you get other persons SDP, then you can communicate with them, but the issue is somehow intiially you need to send the SDP to other side], GoogleMeet when used from phone uses Voip


![Three OR Two Environments used to maintain a working fullStack company webApp](image-7.png)
-> Dev Branch         : So, when you fork a project and run it locally, in some new branch of yours, to make changes and update features, solve some bugs, then the branch in which you are working is your dev branch
-> Staging Branch     : Now, once the developers do their work, the merges happen very actively, so everything that gets merged goes to staging branch and staging area gets updated with new changes. [Like app.100xdevs.com also have staging site : staging.app.100xdevs.com]. So, all developers merges go to direct display to the staging environment, and if ever some commit breaks the code, then the staging environment goes down [which is also sometimes called dev environment is down]
-> Production Branch  : Now, production branch is something which is not updated as frequently as staging environment, it is updated with new merges every 2 weeks after all bugs are fixed


![you can also do this in relationships](image-8.png)

9. Normal Join vs Full Join
10. Try Project => Paytm
11. E-commerce website => tricky part to do is : if you have 5 things to sell, only 5 people could be able to buy, never let inventory go to negative.
12. Hydration Error in fresh Next Appp
13. notification system : it is build using queues
14. microservices : you donot have one big backend, you have divided it into different services, like auth service which only do authentication related task, and then you have todo Servoce, which actually does all todo tasks. Now see microservices are not needed in all cases, monolithic is way to go, use only when highly required 
15. How to preview pdfs : if user uploaded  => u can use pdfviewers but there is problem with them, that they might not be compatible with all e=devicez [like pdfJS library], other way is convert it into imaeges, decompose those to images, and render that image into frontend
16. How to upload files : 
    -> BAD WAY : use multer : from your backend uploading it to S3
    -> GOOD WAY : generate pre-signed URLs and let user upload directly from frontend to server

17. Learn about ETL pipelines, queues